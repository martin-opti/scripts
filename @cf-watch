#!/bin/bash
# Script to watch one or more CI pipelines in Codefresh. This makes it easy to
# see when your pipelines have completed.

# For tput codes (terminfo), see
# https://gist.github.com/izabera/9903f9d942e2667ef2cb

# Go to start of previous line
UPLINE="$(tput cuu1)$(tput cr)"
# Clear to end of line
ERASERIGHT=$(tput el)

# https://unix.stackexchange.com/questions/269077/tput-setaf-color-table-how-to-determine-color-codes
COLOR_RED=$(tput setaf 1)
COLOR_GREEN=$(tput setaf 2)
COLOR_YELLOW=$(tput setaf 3)
COLOR_BLUE=$(tput setaf 4)
COLOR_MAGENTA=$(tput setaf 5)
COLOR_CYAN=$(tput setaf 6)
COLOR_WHITE=$(tput setaf 7)
RESET_STYLE=$(tput sgr0)

CURSOR_INVISIBLE=$(tput civis)
CURSOR_RESET=$(tput cnorm)

current_cursor_row=0

notify () {
    title="$1"
    body="$2"

    sound="$3"
    if [[ -z "$sound" ]]; then
        sound="Purr"
    fi

    osascript -e "display notification \"$body\" with title \"$title\" sound name \"$sound\""
}

notified=()
# Notify that a pipeline completed, with a message about its status.
# Ensures that we only notify once for a given build.
notify_completion () {
    build_id="$1"
    message="$2"
    sound="$3"

    # Check if we have already notified completion for this build
    for id in "${notified[@]}"; do
        if [[ "$id" == "$build_id" ]]; then
            return 0
        fi
    done

    notify "$PIPELINE_NAME" "$message" "$sound"
    notified+=("$build_id")
}

print_status () {
    status="$1"

    # Reset cursor to the top and clear lines
    while [[ "$current_cursor_row" -gt 0 ]]; do
        printf "${UPLINE}"
        current_cursor_row=$((current_cursor_row - 1))
    done

    while IFS= read -r s; do
        id=$(echo $s | jq -r '.id')
        state=$(echo $s | jq -r '.status')
        trigger=$(echo $s | jq -r '.trigger')

        printf "${ERASERIGHT}"

        if [[ "$state" == "running" ]]; then
            printf "${COLOR_BLUE}[Running]${RESET_STYLE} $trigger\n"
        elif [[ "$state" == "success" ]]; then
            printf "${COLOR_GREEN}[Done]${RESET_STYLE} $trigger\n"
            notify_completion "$id" "$trigger completed successfully"
        elif [[ "$state" == "error" ]]; then
            printf "${COLOR_RED}[Failed]${RESET_STYLE} $trigger\n"
            notify_completion "$id" "$trigger failed" "Basso"
        elif [[ "$state" == "terminated" ]]; then
            printf "${COLOR_MAGENTA}[Terminated]${RESET_STYLE} $trigger\n"
            notify_completion "$id" "$trigger was terminated" "Basso"
        fi

        current_cursor_row=$((current_cursor_row + 1))
    done <<< "$status"
}

check_if_done() {
    status="$1"

    completed=0
    failed=0
    total=0

    while IFS= read -r s; do
        state=$(echo $s | jq -r '.status')

        if [[ "$state" != "running" ]]; then
            completed=$((completed + 1))
        fi

        if [[ "$state" == "error" ]]; then
            failed=$((failed + 1))
        fi

        total=$((total + 1))
    done <<< "$status"

    failed_msg=""
    if [[ "$failed" -gt 0 ]]; then
        failed_msg=" ($failed failed)"
    fi

    if [[ "$completed" -eq "$total" ]]; then
        notify "$PIPELINE_NAME" "All $REPO_NAME pipelines completed${failed_msg}"
        exit 0
    fi
}


# Script args
PIPELINE_NAME="$1"
REPO_NAME="$2"

if [[ -z "$PIPELINE_NAME" || -z "$REPO_NAME" ]]; then
    echo "Usage: $0 <pipeline-name> <repo-name>"
    exit 1
fi

# Find running builds for given pipeline and repo
BUILD_IDS=$(codefresh get builds --pipeline-name "optimove-microservices/$PIPELINE_NAME" --status running -o json \
    | jq -r "if type==\"array\" then .[] else . end | select(.repository | contains(\"$REPO_NAME\")) | .id")

if [[ -z "$BUILD_IDS" ]]; then
    echo "No running builds found."
    exit 2
fi

# Don't show cursor in the output
printf "$CURSOR_INVISIBLE"
trap "printf $CURSOR_RESET" EXIT

while true; do
    status=$(codefresh get builds $BUILD_IDS -o json \
        | jq -r -c 'if type=="array" then .[] else . end | {id, trigger, status, totalTime}')

    print_status "$status"
    check_if_done "$status"

    sleep 10
done
